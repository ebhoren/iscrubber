// Generated by CoffeeScript 1.8.0

/*
  jQuery iScrubber plugin 1.2.0

  @preserve
  Created by Marco Martins
  https://github.com/skarface/iscrubber.git
 */

(function() {
  $.fn.iscrubber = function(customOptions) {
    var activeDirection, options, scrub, _direction;
    _direction = {
      horizontal: 'horizontal',
      vertical: 'vertical',

      /* combined works either horizontal or vertical, depending on the direction from where the mouse entered the element */
      combined: 'combined'
    };
    $.fn.iscrubber.defaultOptions = {
      showItem: 1,
      leaveToFirst: true,
      direction: _direction.horizontal
    };

    /* Set the options */
    options = $.extend({}, $.fn.iscrubber.defaultOptions, customOptions);

    /* Set starting active direction. This gets changed only by the combined option. */
    activeDirection = options.direction;

    /* scrub function */
    scrub = function(elements, itemToShow) {
      elements.css('display', 'none');
      return $(elements[itemToShow - 1]).css('display', 'block');
    };
    return this.each(function() {
      var $this, directionX, directionY, elements, height, horizontalTrigger, lastX, lastY, numberOfChildren, originX, originY, verticalTrigger, width, _ref;
      $this = $(this);
      if ($this.data('iscrubber-enabled')) {
        return;
      }
      $this.data('iscrubber-enabled', true);

      /* get elements */
      elements = $this.find('li');

      /* set correct width from children and add minimal css require */
      width = elements.first().width();
      height = elements.first().height();
      $this.width(width).height(height).css('padding', 0);
      numberOfChildren = $this.children().length;

      /* get trigger size => (scrubber size / number of children) */
      horizontalTrigger = width / numberOfChildren;
      verticalTrigger = height / numberOfChildren;

      /* show first element */
      scrub(elements, options.showItem);

      /* state variables for combined mode */
      _ref = [null, null, null, null, true, true], lastX = _ref[0], lastY = _ref[1], originX = _ref[2], originY = _ref[3], directionX = _ref[4], directionY = _ref[5];

      /* bind event when mouse moves over scrubber */
      $this.on('mousemove.iscrubber', function(e) {
        var horizontalDistanceToEdge, index, newDirectionX, newDirectionY, verticalDistanceToEdge, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
        if (activeDirection === _direction.combined) {

          /* starting direction depends on the side from which the mouse entered the element */
          horizontalDistanceToEdge = Math.min(Math.abs(e.pageX - $this.offset().left), Math.abs(e.pageX - $this.offset().left - width));
          verticalDistanceToEdge = Math.min(Math.abs(e.pageY - $this.offset().top), Math.abs(e.pageY - $this.offset().top - height));
          if (horizontalDistanceToEdge < verticalDistanceToEdge) {
            activeDirection = _direction.horizontal;
          } else {
            activeDirection = _direction.vertical;
          }
          _ref1 = [e.pageX, e.pageY, e.pageX, e.pageY], lastX = _ref1[0], lastY = _ref1[1], originX = _ref1[2], originY = _ref1[3];
        }
        if (options.direction === _direction.combined) {

          /* allow to change direction in between, if the user starts moving significantly in the opposite direction */
          if (activeDirection === _direction.horizontal && Math.abs(e.pageY - originY) > height * 0.25) {
            activeDirection = _direction.vertical;
            _ref2 = [e.pageX, e.pageY], originX = _ref2[0], originY = _ref2[1];
          } else if (activeDirection === _direction.vertical && Math.abs(e.pageX - originX) > width * 0.25) {
            activeDirection = _direction.horizontal;
            _ref3 = [e.pageX, e.pageY], originX = _ref3[0], originY = _ref3[1];
          }

          /* determine which direction the user is moving right now */
          _ref4 = [e.pageX > lastX, e.pageY > lastY], newDirectionX = _ref4[0], newDirectionY = _ref4[1];

          /* change origin when user reverses mouse movement direction */
          if (newDirectionX !== directionX) {
            originX = e.pageX;
          }
          if (newDirectionY !== directionY) {
            originY = e.pageY;
          }

          /* save for next frame */
          _ref5 = [e.pageX, e.pageY], lastX = _ref5[0], lastY = _ref5[1];
          _ref6 = [newDirectionX, newDirectionY], directionX = _ref6[0], directionY = _ref6[1];
        }

        /* get the index of image to display on top */
        switch (activeDirection) {
          case _direction.horizontal:
            index = Math.ceil((e.pageX - $this.offset().left) / horizontalTrigger);
            break;
          case _direction.vertical:
            index = Math.ceil((e.pageY - $this.offset().top) / verticalTrigger);
        }
        index = Math.min(Math.max(index, 1), numberOfChildren);
        return scrub(elements, index);
      });
      return $this.on('mouseleave.iscrubber', function() {
        if (options.leaveToFirst === true) {
          scrub(elements, options.showItem);
        }
        if (options.direction === _direction.combined) {
          return activeDirection = _direction.combined;
        }
      });
    });
  };

}).call(this);


//# sourceMappingURL=jquery.iscrubber.js.map
