// Generated by CoffeeScript 1.8.0

/*
  jQuery iScrubber plugin 1.1.0

  @preserve
  Created by Marco Martins
  https://github.com/skarface/iscrubber.git
 */
$.fn.iscrubber = function(customOptions) {
  var DIRECTION, activeDirection, options, scrub;
  DIRECTION = {
    HORIZONTAL: 'horizontal',
    VERTICAL: 'vertical',

    /* combined works either horizontal or vertical, depending on the direction from where the mouse entered the element */
    COMBINED: 'combined'
  };
  $.fn.iscrubber.defaultOptions = {
    showItem: 1,
    leaveToFirst: true,
    direction: DIRECTION.HORIZONTAL
  };

  /* Set the options */
  options = $.extend({}, $.fn.iscrubber.defaultOptions, customOptions);

  /* Set starting active direction. This gets changed only by the combined option. */
  activeDirection = options.direction;

  /* scrub function */
  scrub = function(elements, itemToShow) {
    if (options.hideWithClass) {
      elements.addClass(options.hideWithClass);
      return $(elements[itemToShow - 1]).removeClass(options.hideWithClass);
    } else {
      elements.css('display', 'none');
      return $(elements[itemToShow - 1]).css('display', 'block');
    }
  };
  return this.each(function() {
    var $this, directionX, directionY, elements, height, horizontalTrigger, lastX, lastY, numberOfChildren, originX, originY, verticalTrigger, width, _ref;
    $this = $(this);
    if ($this.data('iscrubber-enabled')) {
      return;
    }
    $this.data('iscrubber-enabled', true);

    /* get elements */
    elements = $this.find('li');

    /* set correct width from children and add minimal css require */
    width = elements.first().width();
    height = elements.first().height();
    $this.width(width).height(height).css('padding', 0);
    numberOfChildren = $this.children().length;

    /* get trigger size => (scrubber size / number of children) */
    horizontalTrigger = width / numberOfChildren;
    verticalTrigger = height / numberOfChildren;

    /* show first element */
    scrub(elements, options.showItem);

    /* state variables for combined mode */
    _ref = [null, null, null, null, true, true], lastX = _ref[0], lastY = _ref[1], originX = _ref[2], originY = _ref[3], directionX = _ref[4], directionY = _ref[5];

    /* bind event when mouse moves over scrubber */
    $this.on('mousemove.iscrubber', function(e) {
      var horizontalDistanceToEdge, index, newDirectionX, newDirectionY, verticalDistanceToEdge, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      if (activeDirection === DIRECTION.COMBINED) {

        /* starting direction depends on the side from which the mouse entered the element */
        horizontalDistanceToEdge = Math.min(Math.abs(e.pageX - $this.offset().left), Math.abs(e.pageX - $this.offset().left - width));
        verticalDistanceToEdge = Math.min(Math.abs(e.pageY - $this.offset().top), Math.abs(e.pageY - $this.offset().top - height));
        if (horizontalDistanceToEdge < verticalDistanceToEdge) {
          activeDirection = DIRECTION.HORIZONTAL;
        } else {
          activeDirection = DIRECTION.VERTICAL;
        }
        _ref1 = [e.pageX, e.pageY, e.pageX, e.pageY], lastX = _ref1[0], lastY = _ref1[1], originX = _ref1[2], originY = _ref1[3];
      }
      if (options.direction === DIRECTION.COMBINED) {

        /* allow to change direction in between, if the user starts moving significantly in the opposite direction */
        if (activeDirection === DIRECTION.HORIZONTAL && Math.abs(e.pageY - originY) > height * 0.25) {
          activeDirection = DIRECTION.VERTICAL;
          _ref2 = [e.pageX, e.pageY], originX = _ref2[0], originY = _ref2[1];
        } else if (activeDirection === DIRECTION.VERTICAL && Math.abs(e.pageX - originX) > width * 0.25) {
          activeDirection = DIRECTION.HORIZONTAL;
          _ref3 = [e.pageX, e.pageY], originX = _ref3[0], originY = _ref3[1];
        }

        /* determine which direction the user is moving right now */
        _ref4 = [e.pageX > lastX, e.pageY > lastY], newDirectionX = _ref4[0], newDirectionY = _ref4[1];

        /* change origin when user reverses mouse movement direction */
        if (newDirectionX !== directionX) {
          originX = e.pageX;
        }
        if (newDirectionY !== directionY) {
          originY = e.pageY;
        }

        /* save for next frame */
        _ref5 = [e.pageX, e.pageY], lastX = _ref5[0], lastY = _ref5[1];
        _ref6 = [newDirectionX, newDirectionY], directionX = _ref6[0], directionY = _ref6[1];
      }

      /* get the index of image to display on top */
      switch (activeDirection) {
        case DIRECTION.HORIZONTAL:
          index = Math.ceil((e.pageX - $this.offset().left) / horizontalTrigger);
          break;
        case DIRECTION.VERTICAL:
          index = Math.ceil((e.pageY - $this.offset().top) / verticalTrigger);
      }
      index = Math.min(Math.max(index, 1), numberOfChildren);
      return scrub(elements, index);
    });
    return $this.on('mouseleave.iscrubber', function() {
      if (options.leaveToFirst === true) {
        scrub(elements, options.showItem);
      }
      if (options.direction === DIRECTION.COMBINED) {
        return activeDirection = DIRECTION.COMBINED;
      }
    });
  });
};


//# sourceMappingURL=jquery.iscrubber.js.map
